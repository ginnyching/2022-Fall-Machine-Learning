# -*- coding: utf-8 -*-
"""Fisher’s linear discriminant.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ju_6aO9y5EPH16PZsTIHpb3xO74ET3SR
"""

import numpy as np
import matplotlib.pyplot as plt

x_train, x_test, y_train, y_test = np.load(
    'classification_data.npy', allow_pickle=True)

print(x_train.shape)
print(y_train.shape)
print(x_test.shape)
print(y_test.shape)

"""1. Compute the mean vectors mi, (i=1,2) of each 2 classes"""

x1 = x_train[y_train == 0]
x2 = x_train[y_train == 1]

# mean vector of each class
m1 = np.mean(x1, axis=0)
m2 = np.mean(x2, axis=0)

print(f"mean vector of class 1: {m1}", f"mean vector of class 2: {m2}")

"""2. Compute the Within-class scatter matrix $S_{w}$

    $S_{j}=\Sigma(x_{j}-m_{j})(x_{j}-m_{j})^{T},for \ j=1,2$

    $S_{w}=S_{1}+S_{2}$
"""

# compute sw
sw = np.matmul((x1-m1).T, (x1-m1)) + np.matmul((x2-m2).T, (x2-m2))

print(f"Within-class scatter matrix SW: {sw}")

"""3. Compute the Between-class scatter matrix $S_{B}$

  $S_{B}=(m_{2}-m_{1})(m_{2}-m_{1})^{T}$
"""

# compute sb
sb = np.matmul(((m2-m1).reshape(-1, 1)), ((m2-m1).reshape(-1, 1).T))

print(f"Between-class scatter matrix SB: {sb}")

"""4. Compute the Fisher’s linear discriminant

$\qquad w \propto S_{w}^{-1}(m_{2}-m_{1})$
"""

# compute w
w = np.matmul(np.linalg.inv(sw), (m2-m1)).reshape(-1, 1)

print(f" Fisher’s linear discriminant: {w}")

"""5. Project the test data by linear discriminant and get the class prediction by K nearest-neighbor rule. Please report the accuracy score with K values from 1 to 5"""

# compute project data
train_project = np.matmul(x_train, w) * (w/np.sum(np.dot(w.T, w))).reshape(-1,)
test_project = np.matmul(x_test, w) * (w/np.sum(np.dot(w.T, w))).reshape(-1,)
# train_project

# Calculate accuracy score


def accuracy_score(y_test, y_pred):
    correct = 0
    for y1, y2 in zip(y_test, y_pred):
        if y1 == y2:
            correct += 1
    return correct/len(y_pred)


# store the accuracy score for each K value
acc = []
for k in range(1, 6):
    y_pred = []
    # make sure y_pred is clear without previous info
    del y_pred[:]
    for test in test_project:
        # store the distnces as list
        dis = []

        for train in train_project:
            distance = np.sum((test-train)**2)
            dis.append(distance)

        dis = np.array(dis).reshape(-1,)
        # sort dis and find the top k index
        index = np.argpartition(dis, k)[:k]
        # print(index)

        y_exact = y_train[index]
        '''
      y_exact=0 or 1
      np.bincount() returns the number of appearance of 0s and 1s ->[# of 0s, #of 1s]
      np.argmax() returns the index of the biggest value -> 0 or 1 which has the higher occurence
      pred_value= 0 or 1
      '''
        pred_value = np.argmax(np.bincount(y_exact))
        y_pred.append(pred_value)

    acc.append(accuracy_score(y_test, y_pred))

print(f"Accuracy of test-set {acc}")

for i in range(1, 6):
    print("Accuracy of test-set k =", i, ": ", acc[i-1])

"""6. Plot the 

1) best projection line on the training data and show the slope and intercept on the title (you can choose any value of intercept for better visualization)

2) colorize the data with each class 

3) project all data points on your projection line. 
"""

# np.polyfit finds the best result for slope and intercept
# takes input as(x,y,degree), since we are ploting a linear line, degree=1,and will return a,b from y=ax+b
# take first column of train_project as x and second column as y
slope, intercept = np.polyfit(train_project[:, 0], train_project[:, 1], 1)
# original data
x1 = x_train[y_train == 0]
y1 = x_train[y_train == 1]

# project data
x2 = train_project[y_train == 0]
y2 = train_project[y_train == 1]

plt.figure(figsize=(8, 8))

# 2)colorize data
# plt.scatter takes input as (x,y,size of dot,color,transparency,marker)
# take first column of xi,yi data as x and second column as y
# color xi as red and yi as blue
plt.scatter(x1[:, 0], x1[:, 1], s=20, c='r', alpha=0.3)
plt.scatter(x2[:, 0], x2[:, 1], s=20, c='r', alpha=0.3)
plt.scatter(y1[:, 0], y1[:, 1], s=20, c='b', alpha=0.3)
plt.scatter(y2[:, 0], y2[:, 1], s=20, c='b', alpha=0.3)

# 3)project data points to projection line
for point in np.c_[x1, x2]:
    '''
    point[0]=x1[:, 0]
    point[1]=x1[:, 1]
    point[2]=x2[:, 0]
    point[3]=x2[:, 1]
    '''
    plt.plot([point[0], point[2]], [point[1], point[3]],
             alpha=0.1, color="r")

for point in np.c_[y1, y2]:
    '''
    point[0]=y1[:, 0]
    point[1]=y1[:, 1]
    point[2]=y2[:, 0]
    point[3]=y2[:, 1]
    '''
    plt.plot([point[0], point[2]], [point[1], point[3]],
             alpha=0.1, color="b")

# 1)best projection line and title
plt.title('Projection Line: w=%f, b=%f' % (slope, intercept), fontsize=20)
plt.plot(train_project[:, 0], train_project[:, 1],
         alpha=1, color="c", linewidth=2.0)

plt.show()
